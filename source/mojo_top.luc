module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,      // AVR RX buffer full
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
  ) {
  
  sig rst;                  // reset signal
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    .rst(rst){
      //ctr is used to store value of input a, b and your answer
      dff ctr_a[16];
      dff ctr_b[16];
      dff ctr_alufn[6];
      //counter is used to add delay 
      dff counter[30];
      
      //fsm states to facilitate testing
      //row1:manual  row2-5:auto
      fsm state = {START,ST_A, ST_B,SHOW_A,SHOW_B,OUT, 
                           ADDERTEST1, ADDERTEST2, ADDERTEST3, ADDERTESTERROR,
                           BOOLEANTEST1, BOOLEANTEST2, BOOLEANTEST3, BOOLEANTEST4, BOOLEANTESTERROR, 
                           SHIFTTEST1, SHIFTTEST2, SHIFTTEST3, SHIFTTESTERROR,
                           COMPTEST1, COMPTEST2, COMPTEST3, COMPTEST4, COMPTEST5, COMPTEST6, COMPTESTERROR};
      //initialize multi seven seg to show numbers
      multi_seven_seg seg;
      }
  }
  
  //define intermediate signals
  sig alu[16];
  const X = 26;
  //initializes the alu
  alu alu1;
  
  //initialize counter for a,b
  
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    led = 8h00;             // turn LEDs off
    spi_miso = bz;          // not using SPI
    spi_channel = bzzzz;    // not using flags
    avr_rx = bz;            // not using serial port
    
    io_led = 3x{{8h00}};    // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    
    

  
    //connect the alu inputs to intermediate variables
    alu1.a = ctr_a.q;
    alu1.b = ctr_b.q;
    alu1.alufn = ctr_alufn.q;
    led[5:0] = ctr_alufn.q;             //indicate alufn
    
    //connect the alu outputs to intermediate variable
    alu = alu1.alu_output;
    
    //connect led to intermediate variable
    io_led = {alu[15-:8],alu[7-:8],8h00}; 
    
    
    seg.values = {4he, 4he, 4he, 4he}; //to initialize the values for 7segment to be ----
    
    
    
    //FSM TEST CASES
    case(state.q){
      //START STATE
      state.START:

        //display 'S---' to indicate START STATE
        seg.values = {4hd, 4he, 4he, 4he};
        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //press the central button to store input a
        //press the left button to show input a
        //press the right button to show input b
        //press the up button to show output 
        //press the down button to start autotest
        
        if(io_button[1]==1){ 
          counter.d = 0;
          state.d = state.ST_A;
        }else if(io_button[3]==1){ 
          state.d = state.SHOW_A;
        }else if(io_button[4]==1){ 
          state.d = state.SHOW_B;
        }else if(io_button[0]==1){ 
          state.d = state.OUT;
        }else if(io_button[2]==1){ 
          counter.d = 0;
          state.d = state.ADDERTEST1;
          
        }
      
      
        
        //STORE input A
      state.ST_A:
        ctr_a.d[15-:8] = io_dip[2];
        ctr_a.d[7-:8] = io_dip[1];            
        
        //input a light up as led
        io_led[2] = ctr_a.q[15-:8];                  
        io_led[1] = ctr_a.q[7-:8];                      

        //display 'A---' to indicate ST_A
        seg.values = {4ha, 4he, 4he, 4he};
        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //increment counter to add delay to same button press
        counter.d = counter.q+1;
        
        //press the central button to store input b
        //press the left button to show input a
        //press the right button to show input b
        //press the up button to show output 
        //press the down button to start autotest
        
        if(counter.q[29:23]>1&&io_button[1]==1){ 
          counter.d = 0;
          state.d = state.ST_B;
        }else if(io_button[3]==1){ 
          state.d = state.SHOW_A;
        }else if(io_button[4]==1){ 
          state.d = state.SHOW_B;
        }else if(io_button[0]==1){ 
          state.d = state.OUT;
        }else if(io_button[2]==1){ 
          counter.d = 0;
          state.d = state.ADDERTEST1;
          
        }
        
        
        
        //STORE input B
      state.ST_B:
        ctr_b.d[15-:8] = io_dip[2];
        ctr_b.d[7-:8] = io_dip[1];
        
        //input b light up as led
        io_led[2] = ctr_b.q[15-:8];                  
        io_led[1] = ctr_b.q[7-:8];                      

        //display 'B---' to indicate ST_B
        seg.values = {4hb, 4he, 4he, 4he};
        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //increment counter to add delay to same button press
        counter.d = counter.q+1;
        
        //press the central button to store input ans
        //press the left button to show input a
        //press the right button to show input b
        //press the up button to show output 
        //press the down button to start autotest
        
        if(counter.q[29:23]>1&&io_button[1]==1){ 
          counter.d = 0;
          state.d = state.ST_A;
        }else if(io_button[3]==1){ 
          state.d = state.SHOW_A;
        }else if(io_button[4]==1){ 
          state.d = state.SHOW_B;
        }else if(io_button[0]==1){ 
          state.d = state.OUT;
        }else if(io_button[2]==1){ 
          counter.d = 0;
          state.d = state.ADDERTEST1;
          
        }
        
        
      
        
      
        //SHOW output
      state.OUT:
        ctr_alufn.d = io_dip[0][5:0];
        
        //output light up as led
        io_led[2] = alu[15-:8];                  
        io_led[1] = alu[7-:8];                      

        //display 'C---' to indicate output
        seg.values = {4hc, 4he, 4he, 4he};
        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //press the central button to store input a
        //press the left button to show input a
        //press the right button to show input b
        //press the up button to show output 
        //press the down button to start autotest
        
        if(io_button[1]==1){ 
          counter.d = 0;
          state.d = state.ST_A;
        }else if(io_button[3]==1){ 
          state.d = state.SHOW_A;
        }else if(io_button[4]==1){ 
          state.d = state.SHOW_B;
        }else if(io_button[0]==1){ 
          state.d = state.OUT;
        }else if(io_button[2]==1){ 
          counter.d = 0;
          state.d = state.ADDERTEST1;
          
        }
        
        

        
        
       
        //Show input A
      state.SHOW_A:

        //input a light up as led
        io_led[2] = ctr_a.q[15-:8];                  
        io_led[1] = ctr_a.q[7-:8];                      

        //display 'S--A' to indicate Show_A
        seg.values = {4hd, 4he, 4he, 4ha};
        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
       
        //press the central button to store input a
        //press the left button to show input a
        //press the right button to show input b
        //press the up button to show output 
        //press the down button to start autotest
        
        if(io_button[1]==1){ 
          counter.d = 0;
          state.d = state.ST_A;
        }else if(io_button[3]==1){ 
          state.d = state.SHOW_A;
        }else if(io_button[4]==1){ 
          state.d = state.SHOW_B;
        }else if(io_button[0]==1){ 
          state.d = state.OUT;
        }else if(io_button[2]==1){ 
          counter.d = 0;
          state.d = state.ADDERTEST1;

        }
        
        
        
        //Show input B
      state.SHOW_B:

        //input b light up as led
        io_led[2] = ctr_b.q[15-:8];                  
        io_led[1] = ctr_b.q[7-:8];                      

        //display 'S--B' to indicate Show_B
        seg.values = {4hd, 4he, 4he, 4hb};
        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //press the central button to store input a
        //press the left button to show input a
        //press the right button to show input b
        //press the up button to show output 
        //press the down button to start autotest
        
        if(io_button[1]==1){ 
          counter.d = 0;
          state.d = state.ST_A;
        }else if(io_button[3]==1){ 
          state.d = state.SHOW_A;
        }else if(io_button[4]==1){ 
          state.d = state.SHOW_B;
        }else if(io_button[0]==1){ 
          state.d = state.OUT;
        }else if(io_button[2]==1){ 
          counter.d = 0;
          state.d = state.ADDERTEST1;
        }
        
        
        
        
      //ADDER TEST 1
      // a=-40, b=-62, alufn[0]=0, output=-40+(-62)=-102
      state.ADDERTEST1:
        ctr_alufn.d = 6b0;
        ctr_a.d = 16b1111111111011000;
        ctr_b.d = 16b1111111111000010;

        case(counter.q[X+1:X]){
             b01:io_led[2:1] = {ctr_a.q[15-:8],ctr_a.q[7-:8]}; seg.values = {4ha, 4h1, 4he, 4ha};// "A1-A":showing input A
             b10:io_led[2:1] = {ctr_b.q[15-:8],ctr_b.q[7-:8]}; seg.values = {4ha, 4h1, 4he, 4hb};// "A1-B":showing input B
             b11:io_led[2:1] = {alu[15-:8],alu[7-:8]}; 
                  if(alu==16b1111111110011010){seg.values = {4h9, 4ha, 4hd, 4hd}; }// "PASS":correct output
                  else{seg.values = {4ha, 4h1, 4he, 4hf};} // "A1-E":incorrect output
             default:  io_led[2:1] = 2x{{8h00}}; seg.values = {4ha, 4h1, 4he, 4he}; //display 'A1--'
        }                         

        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //increment clock counter 
        counter.d = counter.q+1;
        if(counter.q[X+2]==1){
          counter.d = 0; //reset counter for the next state
          state.d = state.ADDERTEST2; //move to the next state
        }
        
        
        
        
        
        
      //ADDER TEST 2
      // a=-40, b=-62, alufn[0]=1, output=-40-(-62)=22        
      state.ADDERTEST2:
        ctr_alufn.d = 6b1;
        ctr_a.d = 16b1111111111011000;
        ctr_b.d = 16b1111111111000010;

        case(counter.q[X+1:X]){
             b01:io_led[2:1] = {ctr_a.q[15-:8],ctr_a.q[7-:8]}; seg.values = {4ha, 4h2, 4he, 4ha};// "A2-A":showing input A
             b10:io_led[2:1] = {ctr_b.q[15-:8],ctr_b.q[7-:8]}; seg.values = {4ha, 4h2, 4he, 4hb};// "A2-B":showing input B
             b11:io_led[2:1] = {alu[15-:8],alu[7-:8]}; 
                  if(alu==16b0000000000010110){seg.values = {4h9, 4ha, 4hd, 4hd}; }// "PASS":correct output
                  else{seg.values = {4ha, 4h2, 4he, 4hf};} // "A2-E":incorrect output
             default:io_led[2:1] = 2x{{8h00}}; seg.values = {4ha, 4h2, 4he, 4he}; //display 'A2--'
        }                         
       
        
        //display 'A2--' to indicate ADDER TEST 2
        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //increment clock counter 
        counter.d = counter.q+1;
        
        if(counter.q[X+2]==1){
          counter.d = 0; //reset counter for the next state
          state.d = state.ADDERTEST3; //move to the next state
        }
        
        
        
        
      //ADDER TEST 3
      // a=4, b=62, alufn[1:0]=2b10, output=4*62=248        
      state.ADDERTEST3:
        ctr_alufn.d = 6b10;
        ctr_a.d = 16b0000000000000100;
        ctr_b.d = 16b0000000000111110;

        case(counter.q[X+1:X]){
             b01:io_led[2:1] = {ctr_a.q[15-:8],ctr_a.q[7-:8]}; seg.values = {4ha, 4h3, 4he, 4ha};// "A3-A":showing input A
             b10:io_led[2:1] = {ctr_b.q[15-:8],ctr_b.q[7-:8]}; seg.values = {4ha, 4h3, 4he, 4hb};// "A3-B":showing input B
             b11:io_led[2:1] = {alu[15-:8],alu[7-:8]}; 
                  if(alu==16b0000000011111000){seg.values = {4h9, 4ha, 4hd, 4hd}; }// "PASS":correct output
                  else{seg.values = {4ha, 4h3, 4he, 4hf};} // "A1-E":incorrect output
             default:io_led[2:1] = 2x{{8h00}}; seg.values = {4ha, 4h3, 4he, 4he}; //display 'A3--'
        }                         
       
        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //increment clock counter 
        counter.d = counter.q+1;
        
        if(counter.q[X+2]==1){
          counter.d = 0; //reset counter for the next state
          state.d = state.ADDERTESTERROR; //move to the next state
        }
      
        
        
      //ADDER TEST ERROR
      // a=100, b=100, alufn[0]=0, output=100+100=200       
      state.ADDERTESTERROR:
        ctr_alufn.d = 6b10;
        ctr_a.d = 16b0000000001100100+16b1;//intentional error
        ctr_b.d = 16b0000000001100100;
 
        case(counter.q[X+1:X]){
             b01:io_led[2:1] = {8b0,8b01100100}; seg.values = {4ha, 4hf, 4he, 4ha};// "AE-A":showing input A
             b10:io_led[2:1] = {ctr_b.q[15-:8],ctr_b.q[7-:8]}; seg.values = {4ha, 4hf, 4he, 4hb};// "AE-B":showing input B
             b11:io_led[2:1] = {alu[15-:8],alu[7-:8]}; 
                  if(alu==16b0000000011001000){seg.values = {4h9, 4ha, 4hd, 4hd}; }// "PASS":correct output
                  else{seg.values = {4ha, 4hf, 4he, 4hf};} // "AE-E":incorrect output
             default: io_led[2:1] = 2x{{8h00}};seg.values = {4ha, 4hf, 4he, 4he}; //display 'AE--'
        }                         
       
        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //increment clock counter 
        counter.d = counter.q+1;
        
        if(counter.q[X+2]==1){
          counter.d = 0; //reset counter for the next state
          state.d = state.BOOLEANTEST1; //move to the next state
        }
        
        
        
      //BOOLEAN TEST 1 ('A')
      //a = 16b1111100000000000, b = 16b0000000000011111, alufn[3:0] = 4b1010, output = 16b1111100000000000  
      state.BOOLEANTEST1:
        ctr_alufn.d = 6b011010;
        ctr_a.d = 16b1111100000000000;
        ctr_b.d = 16b0000000000011111;

        case(counter.q[X+1:X]){
             b01:io_led[2:1] = {ctr_a.q[15-:8],ctr_a.q[7-:8]}; seg.values = {4hb, 4h1, 4he, 4ha};// "B1-A":showing input A
             b10:io_led[2:1] = {ctr_b.q[15-:8],ctr_b.q[7-:8]}; seg.values = {4hb, 4h1, 4he, 4hb};// "B1-B":showing input B
             b11:io_led[2:1] = {alu[15-:8],alu[7-:8]}; 
                  if(alu==16b1111100000000000){seg.values = {4h9, 4ha, 4hd, 4hd}; }// "PASS":correct output
                  else{seg.values = {4hb, 4h1, 4he, 4hf};} // "B1-E":incorrect output
             default: io_led[2:1] = 2x{{8h00}};seg.values = {4hb, 4h1, 4he, 4he}; //display 'B1--'
        }                         
       
        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //increment clock counter 
        counter.d = counter.q+1;
        
        if(counter.q[X+2]==1){
          counter.d = 0; //reset counter for the next state
          state.d = state.BOOLEANTEST2; //move to the next state
        }
        
        
        
        
      //BOOLEAN TEST 2 (AND)
      //a = 16b1111100000000000, b = 16b0001111100000000, alufn[3:0] = 4b1000, output = 16b0001100000000000    
      state.BOOLEANTEST2:
        ctr_alufn.d = 6b011000;
        ctr_a.d = 16b1111100000000000;
        ctr_b.d = 16b0001111100000000;

        case(counter.q[X+1:X]){
             b01:io_led[2:1] = {ctr_a.q[15-:8],ctr_a.q[7-:8]}; seg.values = {4hb, 4h2, 4he, 4ha};// "B2-A":showing input A
             b10:io_led[2:1] = {ctr_b.q[15-:8],ctr_b.q[7-:8]}; seg.values = {4hb, 4h2, 4he, 4hb};// "B2-B":showing input B
             b11:io_led[2:1] = {alu[15-:8],alu[7-:8]}; 
                  if(alu==16b0001100000000000){seg.values = {4h9, 4ha, 4hd, 4hd}; }// "PASS":correct output
                  else{seg.values = {4hb, 4h2, 4he, 4hf};} // "B2-E":incorrect output
             default:io_led[2:1] = 2x{{8h00}}; seg.values = {4hb, 4h2, 4he, 4he}; //display 'B2--'
        }                               

        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //increment clock counter 
        counter.d = counter.q+1;
        
        if(counter.q[X+2]==1){
          counter.d = 0; //reset counter for the next state
          state.d = state.BOOLEANTEST3; //move to the next state
        }
        
        
      //BOOLEAN TEST 3 (OR)
      //a = 16b1111100000000000, b = 16b0001111100000000, alufn[3:0] = 4b1110,, output = 16b1111111100000000    
      state.BOOLEANTEST3:
        ctr_alufn.d = 6b011110;
        ctr_a.d = 16b1111100000000000;
        ctr_b.d = 16b0001111100000000;

        case(counter.q[X+1:X]){
             b01:io_led[2:1] = {ctr_a.q[15-:8],ctr_a.q[7-:8]}; seg.values = {4hb, 4h3, 4he, 4ha};// "B3-A":showing input A
             b10:io_led[2:1] = {ctr_b.q[15-:8],ctr_b.q[7-:8]}; seg.values = {4hb, 4h3, 4he, 4hb};// "B3-B":showing input B
             b11:io_led[2:1] = {alu[15-:8],alu[7-:8]}; 
                  if(alu==16b1111111100000000){seg.values = {4h9, 4ha, 4hd, 4hd}; }// "PASS":correct output
                  else{seg.values = {4hb, 4h3, 4he, 4hf};} // "B3-E":incorrect output
             default: io_led[2:1] = 2x{{8h00}};seg.values = {4hb, 4h3, 4he, 4he}; //display 'B3--' 
        }                         

        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //increment clock counter 
        counter.d = counter.q+1;
        
        if(counter.q[X+2]==1){
          counter.d = 0; //reset counter for the next state
          state.d = state.BOOLEANTEST4; //move to the next state
        }
        
        
      //BOOLEAN TEST 4 (XOR)
      //a = 16b1111100000000000, b = 16b0001111100000000, alufn[3:0] = 4b0110, output = 16b1110011100000000    
      state.BOOLEANTEST4:
        ctr_alufn.d = 6b010110;
        ctr_a.d = 16b1111100000000000;
        ctr_b.d = 16b0001111100000000;

        case(counter.q[X+1:X]){
             b01:io_led[2:1] = {ctr_a.q[15-:8],ctr_a.q[7-:8]}; seg.values = {4hb, 4h4, 4he, 4ha};// "B4-A":showing input A
             b10:io_led[2:1] = {ctr_b.q[15-:8],ctr_b.q[7-:8]}; seg.values = {4hb, 4h4, 4he, 4hb};// "B4-B":showing input B
             b11:io_led[2:1] = {alu[15-:8],alu[7-:8]}; 
                  if(alu==16b1110011100000000 ){seg.values = {4h9, 4ha, 4hd, 4hd}; }// "PASS":correct output
                  else{seg.values = {4hb, 4h4, 4he, 4hf};} // "B4-E":incorrect output
             default: io_led[2:1] = 2x{{8h00}};seg.values = {4hb, 4h4, 4he, 4he}; //display 'B4--' 
        }                         

        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //increment clock counter 
        counter.d = counter.q+1;
        
        if(counter.q[X+2]==1){
          counter.d = 0; //reset counter for the next state
          state.d = state.BOOLEANTESTERROR; //move to the next state
        }
        
        
        
      //BOOLEAN TEST ERROR
      //a = 16b1111100000000000, b = 16b0001111100000000, alufn[3:0] = 4b0110, output = 16b1110011100000000    
      state.BOOLEANTESTERROR:
        ctr_alufn.d = 6b010110;
        ctr_a.d = 16b1111100000000000+16b1;//intentional error
        ctr_b.d = 16b0001111100000000;

        case(counter.q[X+2:X]){
             b001:io_led[2:1] = {8b11111000,8b00000000}; seg.values = {4hb, 4hf, 4he, 4ha};// "BE-A":showing input A
             b010:io_led[2:1] = {ctr_b.q[15-:8],ctr_b.q[7-:8]}; seg.values = {4hb, 4hf, 4he, 4hb};// "BE-B":showing input B
             b011:io_led[2:1] = {alu[15-:8],alu[7-:8]}; 
                  if(alu==16b1110011100000000 ){seg.values = {4h9, 4ha, 4hd, 4hd}; }// "PASS":correct output
                  else{seg.values = {4hb, 4hf, 4he, 4hf};} // "BE-E":incorrect output
             default:io_led[2:1] = 2x{{8h00}}; seg.values = {4hb, 4hf, 4he, 4he}; //display 'BE--' 
        }                         

        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //increment clock counter 
        counter.d = counter.q+1;
        
        if(counter.q[X+2]==1){
          counter.d = 0; //reset counter for the next state
          state.d = state.SHIFTTEST1; //move to the next state
        }
        
        
        
        
        
        
        
        
          
      //SHIFT TEST 1 (shift left)
      //a = 16b0000100010000000, b = 16b11, alufn[1:0] = 00, output = 16b0100010000000000  
      state.SHIFTTEST1:
        ctr_alufn.d = 6b100000;
        ctr_a.d = 16b0000100010000000;
        ctr_b.d = 16b11;

        case(counter.q[X+2:X]){
             b001:io_led[2:1] = {ctr_a.q[15-:8],ctr_a.q[7-:8]}; seg.values = {4hd, 4h1, 4he, 4ha};// "S1-A":showing input A
             b010:io_led[2:1] = {ctr_b.q[15-:8],ctr_b.q[7-:8]}; seg.values = {4hd, 4h1, 4he, 4hb};// "S1-B":showing input B
             b011:io_led[2:1] = {alu[15-:8],alu[7-:8]}; 
                  if(alu==16b0100010000000000){seg.values = {4h9, 4ha, 4hd, 4hd}; }// "PASS":correct output
                  else{seg.values = {4hd, 4h1, 4he, 4hf};} // "S1-E":incorrect output
             default: io_led[2:1] = 2x{{8h00}};seg.values = {4hd, 4h1, 4he, 4he}; //display 'S1--' 
        }                         

        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //increment clock counter 
        counter.d = counter.q+1;
        
        if(counter.q[X+2]==1){
          counter.d = 0; //reset counter for the next state
          state.d = state.SHIFTTEST2; //move to the next state
        }
        
        
        
      //SHIFT TEST 2 (shift right)
      //a = 16b0000100010000000, b = 16b11, alufn[1:0] = 01, output = 16b0000000100010000  
      state.SHIFTTEST2:
        ctr_alufn.d = 6b100001;
        ctr_a.d = 16b0000100010000000;
        ctr_b.d = 16b11;

        case(counter.q[X+1:X]){
             b01:io_led[2:1] = {ctr_a.q[15-:8],ctr_a.q[7-:8]}; seg.values = {4hd, 4h2, 4he, 4ha};// "S2-A":showing input A
             b10:io_led[2:1] = {ctr_b.q[15-:8],ctr_b.q[7-:8]}; seg.values = {4hd, 4h2, 4he, 4hb};// "S2-B":showing input B
             b11:io_led[2:1] = {alu[15-:8],alu[7-:8]}; 
                  if(alu==16b0000000100010000 ){seg.values = {4h9, 4ha, 4hd, 4hd}; }// "PASS":correct output
                  else{seg.values = {4hd, 4h2, 4he, 4hf};} // "S2-E":incorrect output
             default: io_led[2:1] = 2x{{8h00}};seg.values = {4hd, 4h2, 4he, 4he}; //display 'S2--'
        }                         

        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //increment clock counter 
        counter.d = counter.q+1;
        
        if(counter.q[X+2]==1){
          counter.d = 0; //reset counter for the next state
          state.d = state.SHIFTTEST3; //move to the next state
        }
        
        
        
        
      //SHIFT TEST 3 (shift right arithmetic)
      //a = 16b1111000010000000, b = 16b100, alufn[1:0] = 11, output = 16b1111111100001000  
      state.SHIFTTEST3:
        ctr_alufn.d = 6b100011;
        ctr_a.d = 16b1111000010000000;
        ctr_b.d = 16b100;

        case(counter.q[X+1:X]){
             b01:io_led[2:1] = {ctr_a.q[15-:8],ctr_a.q[7-:8]}; seg.values = {4hd, 4h3, 4he, 4ha};// "S3-A":showing input A
             b10:io_led[2:1] = {ctr_b.q[15-:8],ctr_b.q[7-:8]}; seg.values = {4hd, 4h3, 4he, 4hb};// "S3-B":showing input B
             b11:io_led[2:1] = {alu[15-:8],alu[7-:8]}; 
                  if(alu==16b1111111100001000){seg.values = {4h9, 4ha, 4hd, 4hd}; }// "PASS":correct output
                  else{seg.values = {4hd, 4h3, 4he, 4hf};} // "S3-E":incorrect output
             default:io_led[2:1] = 2x{{8h00}}; seg.values = {4hd, 4h3, 4he, 4he}; //display "S3--" 
        }                         

        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //increment clock counter 
        counter.d = counter.q+1;
        
        if(counter.q[X+2]==1){
          counter.d = 0; //reset counter for the next state
          state.d = state.SHIFTTESTERROR; //move to the next state
        }
        
        
        
      //SHIFT TEST ERROR
      //a = 16b1111000010000000, b = 16b1, alufn[1:0] = 00, output = 16b1110000100000000  
      state.SHIFTTESTERROR:
        ctr_alufn.d = 6b100000;
        ctr_a.d = 16b1111000010000000+16b1; //intentional error
        ctr_b.d = 16b1;

        case(counter.q[X+1:X]){
             b01:io_led[2:1] = {8b11110000,8b10000000}; seg.values = {4hd, 4hf, 4he, 4ha};// "SE-A":showing input A
             b10:io_led[2:1] = {ctr_b.q[15-:8],ctr_b.q[7-:8]}; seg.values = {4hf, 4h3, 4he, 4hb};// "SE-B":showing input B
             b11:io_led[2:1] = {alu[15-:8],alu[7-:8]}; 
                  if(alu==16b1110000100000000){seg.values = {4h9, 4ha, 4hd, 4hd}; }// "PASS":correct output
                  else{seg.values = {4hd, 4hf, 4he, 4hf};} // "SE-E":incorrect output
             default:io_led[2:1] = 2x{{8h00}}; seg.values = {4ha, 4h2, 4he, 4he}; //display 'SE--' 
        }                         

        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //increment clock counter 
        counter.d = counter.q+1;
        
        if(counter.q[X+2]==1){
          counter.d = 0; //reset counter for the next state
          state.d = state.COMPTEST1; //move to the next state
        }
        
        
        
        
      //COMP TEST 1
      //a = 62, b = 62, alufn[2:1] = 2b01, output = 1 since a==b  
      state.COMPTEST1:
        ctr_alufn.d = 6b110011;
        ctr_a.d = 16b0000000000111110;
        ctr_b.d = 16b0000000000111110;

        case(counter.q[X+1:X]){
             b01:io_led[2:1] = {ctr_a.q[15-:8],ctr_a.q[7-:8]}; seg.values = {4hc, 4h1, 4he, 4ha};// "C1-A":showing input A
             b10:io_led[2:1] = {ctr_b.q[15-:8],ctr_b.q[7-:8]}; seg.values = {4hc, 4h1, 4he, 4hb};// "C1-B":showing input B
             b11:io_led[2:1] = {alu[15-:8],alu[7-:8]}; 
                  if(alu==16b1){seg.values = {4h9, 4ha, 4hd, 4hd}; }// "PASS":correct output
                  else{seg.values = {4hc, 4h1, 4he, 4hf};} // "C1-E":incorrect output
             default: io_led[2:1] = 2x{{8h00}};seg.values = {4hc, 4h1, 4he, 4he}; //display 'C1--'
        }                         

        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //increment clock counter 
        counter.d = counter.q+1;
        
        if(counter.q[X+2]==1){
          counter.d = 0; //reset counter for the next state
          state.d = state.COMPTEST2; //move to the next state
        }
        
        
        
      //COMP TEST 2
      //a = 62, b = 63, alufn[2:1] = 2b01, output = 0 since a!=b  
      state.COMPTEST2:
        ctr_alufn.d = 6b110011;
        ctr_a.d = 16b0000000000111110;
        ctr_b.d = 16b0000000000111111;

        case(counter.q[X+1:X]){
             b01:io_led[2:1] = {ctr_a.q[15-:8],ctr_a.q[7-:8]}; seg.values = {4hc, 4h2, 4he, 4ha};// "C2-A":showing input A
             b10:io_led[2:1] = {ctr_b.q[15-:8],ctr_b.q[7-:8]}; seg.values = {4hc, 4h2, 4he, 4hb};// "C2-B":showing input B
             b11:io_led[2:1] = {alu[15-:8],alu[7-:8]}; 
                  if(alu==16b0){seg.values = {4h9, 4ha, 4hd, 4hd}; }// "PASS":correct output
                  else{seg.values = {4hc, 4h2, 4he, 4hf};} // "C2-E":incorrect output
             default: io_led[2:1] = 2x{{8h00}};seg.values = {4hc, 4h2, 4he, 4he}; //display 'C2--'
        }                         

        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //increment clock counter 
        counter.d = counter.q+1;
        
        if(counter.q[X+2]==1){
          counter.d = 0; //reset counter for the next state
          state.d = state.COMPTEST3; //move to the next state
        }
        
        
      //COMP TEST 3
      //a = 62, b = 63, alufn[2:1] = 2b10, output = 1 since a<b  
      state.COMPTEST3:
        ctr_alufn.d = 6b110101;
        ctr_a.d = 16b0000000000111110;
        ctr_b.d = 16b0000000000111111;

        case(counter.q[X+1:X]){
             b01:io_led[2:1] = {ctr_a.q[15-:8],ctr_a.q[7-:8]}; seg.values = {4hc, 4h3, 4he, 4ha};// "C3-A":showing input A
             b10:io_led[2:1] = {ctr_b.q[15-:8],ctr_b.q[7-:8]}; seg.values = {4hc, 4h3, 4he, 4hb};// "C3-B":showing input B
             b11:io_led[2:1] = {alu[15-:8],alu[7-:8]}; 
                  if(alu==16b1){seg.values = {4h9, 4ha, 4hd, 4hd}; }// "PASS":correct output
                  else{seg.values = {4hc, 4h3, 4he, 4hf};} // "C3-E":incorrect output
             default: io_led[2:1] = 2x{{8h00}};seg.values = {4hc, 4h3, 4he, 4he}; //display 'C3--'
        }                         

        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //increment clock counter 
        counter.d = counter.q+1;
        
        if(counter.q[X+2]==1){
          counter.d = 0; //reset counter for the next state
          state.d = state.COMPTEST4; //move to the next state
        }
        
        
        
        
      //COMP TEST 4
      //a = 63, b = 63, alufn[2:1] = 2b10, output = 0 since !(a<b)  
      state.COMPTEST4:
        ctr_alufn.d = 6b110101;
        ctr_a.d = 16b0000000000111111;
        ctr_b.d = 16b0000000000111111;

        case(counter.q[X+1:X]){
             b01:io_led[2:1] = {ctr_a.q[15-:8],ctr_a.q[7-:8]}; seg.values = {4hc, 4h4, 4he, 4ha};// "C4-A":showing input A
             b10:io_led[2:1] = {ctr_b.q[15-:8],ctr_b.q[7-:8]}; seg.values = {4hc, 4h4, 4he, 4hb};// "C4-B":showing input B
             b11:io_led[2:1] = {alu[15-:8],alu[7-:8]}; 
                  if(alu==16b0){seg.values = {4h9, 4ha, 4hd, 4hd}; }// "PASS":correct output
                  else{seg.values = {4hc, 4h4, 4he, 4hf};} // "C4-E":incorrect output
             default: io_led[2:1] = 2x{{8h00}};seg.values = {4hc, 4h4, 4he, 4he}; //display 'C4--'
        }                         
     
        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //increment clock counter 
        counter.d = counter.q+1;
        
        if(counter.q[X+2]==1){
          counter.d = 0; //reset counter for the next state
          state.d = state.COMPTEST5; //move to the next state
        }
        
        
        
        
      //COMP TEST 5
      //a = 63, b = 63, alufn[2:1] = 2b11, output = 1 since a<=b 
      state.COMPTEST5:
        ctr_alufn.d = 6b110111;
        ctr_a.d = 16b0000000000111111;
        ctr_b.d = 16b0000000000111111;

        case(counter.q[X+1:X]){
             b01:io_led[2:1] = {ctr_a.q[15-:8],ctr_a.q[7-:8]}; seg.values = {4hc, 4h5, 4he, 4ha};// "C5-A":showing input A
             b10:io_led[2:1] = {ctr_b.q[15-:8],ctr_b.q[7-:8]}; seg.values = {4hc, 4h5, 4he, 4hb};// "C5-B":showing input B
             b11:io_led[2:1] = {alu[15-:8],alu[7-:8]}; 
                  if(alu==16b1){seg.values = {4h9, 4ha, 4hd, 4hd}; }// "PASS":correct output
                  else{seg.values = {4hc, 4h5, 4he, 4hf};} // "C5-E":incorrect output
             default:io_led[2:1] = 2x{{8h00}}; seg.values = {4hc, 4h5, 4he, 4he}; //display 'C5--'
        }                         

        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //increment clock counter 
        counter.d = counter.q+1;
        
        if(counter.q[X+2]==1){
          counter.d = 0; //reset counter for the next state
          state.d = state.COMPTEST6; //move to the next state
        }
        
        
        
      //COMP TEST 6
      //a = 63, b = 62, alufn[2:1] = 2b11, output = 0 since !(a<=b) 
      state.COMPTEST6:
        ctr_alufn.d = 6b110111;
        ctr_a.d = 16b0000000000111111;
        ctr_b.d = 16b0000000000111110;

        case(counter.q[X+1:X]){
             b01:io_led[2:1] = {ctr_a.q[15-:8],ctr_a.q[7-:8]}; seg.values = {4hc, 4h6, 4he, 4ha};// "C6-A":showing input A
             b10:io_led[2:1] = {ctr_b.q[15-:8],ctr_b.q[7-:8]}; seg.values = {4hc, 4h6, 4he, 4hb};// "C6-B":showing input B
             b11:io_led[2:1] = {alu[15-:8],alu[7-:8]}; 
                  if(alu==16b0){seg.values = {4h9, 4ha, 4hd, 4hd}; }// "PASS":correct output
                  else{seg.values = {4hc, 4h6, 4he, 4hf};} // "C6-E":incorrect output
             default:io_led[2:1] = 2x{{8h00}}; seg.values = {4hc, 4h6, 4he, 4he}; //display 'C6--'
        }                         

        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //increment clock counter 
        counter.d = counter.q+1;
        
        if(counter.q[X+2]==1){
          counter.d = 0; //reset counter for the next state
          state.d = state.COMPTESTERROR; //move to the next state
        }
        
        
        
        
      //COMP TEST ERROR
      //a = 62, b = 62, alufn[2:1] = 2b01, output = 1 since a==b  
      state.COMPTESTERROR:
        ctr_alufn.d = 6b110011;
        ctr_a.d = 16b0000000000111110+16b1;
        ctr_b.d = 16b0000000000111110;

        case(counter.q[X+1:X]){
             b01:io_led[2:1] = {8b00000000,8b00111110}; seg.values = {4hc, 4hf, 4he, 4ha};// "CE-A":showing input A
             b10:io_led[2:1] = {ctr_b.q[15-:8],ctr_b.q[7-:8]}; seg.values = {4hc, 4hf, 4he, 4hb};// "CE-B":showing input B
             b11:io_led[2:1] = {alu[15-:8],alu[7-:8]}; 
                  if(alu==16b1){seg.values = {4h9, 4ha, 4hd, 4hd}; }// "PASS":correct output
                  else{seg.values = {4hc, 4hf, 4he, 4hf};} // "CE-E":incorrect output
             default:io_led[2:1] = 2x{{8h00}}; seg.values = {4hc, 4hf, 4he, 4he}; //display 'CE--'
        }                         
       
        io_seg = ~seg.seg;
        io_sel = ~seg.sel;
        
        //increment clock counter 
        counter.d = counter.q+1;
        
        if(counter.q[X+2]==1){
          counter.d = 0; //reset counter for the next state
          state.d = state.START; //move to the start
        }
        
     
        
    }
  }
}